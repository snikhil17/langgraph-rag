def _acall(
    task: weakref.ref[PregelExecutableTask],
    func: Callable[[Any], Union[Awaitable[Any], Any]],
    input: Any,
    *,
    retry: Optional[Sequence[RetryPolicy]] = None,
    callbacks: Callbacks = None,
    # injected dependencies
    futures: weakref.ref[FuturesDict],
    schedule_task: weakref.ref[
        Callable[
            [PregelExecutableTask, int, Optional[Call]], Optional[PregelExecutableTask]
        ]
    ],
    submit: weakref.ref[Submit],
    loop: asyncio.AbstractEventLoop,
    reraise: bool = False,
    stream: bool = False,
) -> Union[asyncio.Future[Any], concurrent.futures.Future[Any]]:
    fut: Optional[asyncio.Future] = None
    # schedule PUSH tasks, collect futures
    scratchpad: PregelScratchpad = task().config[CONF][CONFIG_KEY_SCRATCHPAD]  # type: ignore[union-attr]
    # schedule the next task, if the callback returns one
    if next_task := schedule_task()(  # type: ignore[misc]
        task(),  # type: ignore[arg-type]
        scratchpad.call_counter(),
        Call(func, input, retry=retry, callbacks=callbacks),
    ):
        if fut := next(
            (
                f
                for f, t in futures().items()  # type: ignore[union-attr]
                if t is not None and t == next_task.id
            ),
            None,
        ):
            # if the parent task was retried,
            # the next task might already be running

            pass
        elif next_task.writes:
            # if it already ran, return the result
            fut = asyncio.Future(loop=loop)
            ret = next((v for c, v in next_task.writes if c == RETURN), MISSING)
            if ret is not MISSING:
                fut.set_result(ret)
            elif exc := next((v for c, v in next_task.writes if c == ERROR), None):
                fut.set_exception(
                    exc if isinstance(exc, BaseException) else Exception(exc)
                )
            else:
                fut.set_result(None)
            futures()[fut] = next_task  # type: ignore[index]
        else:
            # schedule the next task
            fut = cast(
                asyncio.Future,
                submit()(  # type: ignore[misc]
                    arun_with_retry,
                    next_task,
                    retry,
                    stream=stream,
                    configurable={
                        CONFIG_KEY_CALL: partial(
                            _acall,
                            weakref.ref(next_task),
                            stream=stream,
                            futures=futures,
                            schedule_task=schedule_task,
                            submit=submit,
                            loop=loop,
                            reraise=reraise,
                        ),
                    },
                    __name__=task().name,  # type: ignore[union-attr]
                    __cancel_on_exit__=True,
                    __reraise_on_exit__=reraise,
                    # starting a new task in the next tick ensures
                    # updates from this tick are committed/streamed first
                    __next_tick__=True,
                ),
            )
            futures()[fut] = next_task  # type: ignore[index]

    fut = cast(Union[asyncio.Future, concurrent.futures.Future], fut)
    # return a chained future to ensure commit() callback is called
    # before the returned future is resolved, to ensure stream order etc
    try:
        in_async = asyncio.current_task() is not None
    except RuntimeError:
        in_async = False
    # if in async context return an async future
    # otherwise return a chained sync future
    if in_async:
        if isinstance(fut, asyncio.Task):
            sfut: Union[asyncio.Future[Any], concurrent.futures.Future[Any]] = (
                asyncio.Future(loop=loop)
            )
            loop.call_soon_threadsafe(chain_future, fut, sfut)
            return sfut
        else:
            # already wrapped in a future
            return fut
    else:
        sfut = concurrent.futures.Future()
        loop.call_soon_threadsafe(chain_future, fut, sfut)
        return sfut