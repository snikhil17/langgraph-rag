def test_subgraph_w_interrupt(
    topics: Topics, checkpointer: BaseCheckpointSaver
) -> None:
    input = {"messages": [{"role": "user", "content": "what's the weather in sf"}]}
    config = {"configurable": {"thread_id": "1"}}
    graph = mk_weather_graph(checkpointer)

    # start a new run
    with DefaultProducer() as producer:
        producer.send(
            topics.orchestrator,
            value=serde.dumps(MessageToOrchestrator(input=input, config=config)),
        )
        producer.flush()

    orch_msgs, exec_msgs = drain_topics(topics, graph)

    # check interrupted state
    state = graph.get_state(config)
    assert state.next == ("weather_graph",)
    assert state.values == {
        "messages": [_AnyIdHumanMessage(content="what's the weather in sf")],
        "route": "weather",
    }

    # check outer history
    history = [c for c in graph.get_state_history(config)]
    assert len(history) == 3

    # check child history
    child_history = [c for c in graph.get_state_history(history[0].tasks[0].state)]
    assert len(child_history) == 3

    # check messages
    assert (
        orch_msgs
        == (
            # initial message to outer graph
            [MessageToOrchestrator(input=input, config=config)]
            # outer graph messages, until interrupted
            + [
                {
                    "config": {
                        "callbacks": None,
                        "configurable": {
                            "__pregel_ensure_latest": True,
                            "__pregel_dedupe_tasks": True,
                            "__pregel_resuming": False,
                            "checkpoint_id": c.config["configurable"]["checkpoint_id"],
                            "checkpoint_ns": "",
                            "thread_id": "1",
                        },
                        "metadata": AnyDict(),
                        "recursion_limit": 25,
                        "tags": [],
                    },
                    "input": None,
                    "finally_send": None,
                }
                for c in reversed(history[1:])  # the last one wasn't executed
                # orchestrator messages appear only after tasks for that checkpoint
                # finish executing, ie. after executor sends message to resume checkpoint
                for _ in c.tasks
            ]
            # initial message to child graph
            + [
                {
                    "config": {
                        "callbacks": None,
                        "configurable": {
                            "__pregel_checkpointer": None,
                            "__pregel_delegate": False,
                            "__pregel_read": None,
                            "__pregel_send": None,
                            "__pregel_call": None,
                            "__pregel_ensure_latest": True,
                            "__pregel_dedupe_tasks": True,
                            "__pregel_resuming": False,
                            "__pregel_previous": None,
                            "__pregel_store": None,
                            "__pregel_task_id": history[0].tasks[0].id,
                            "__pregel_scratchpad": {
                                "subgraph_counter": None,
                                "call_counter": None,
                                "interrupt_counter": None,
                                "get_null_resume": None,
                                "resume": [],
                            },
                            "checkpoint_id": None,
                            "checkpoint_map": {
                                "": history[0].config["configurable"]["checkpoint_id"]
                            },
                            "checkpoint_ns": history[0]
                            .tasks[0]
                            .state["configurable"]["checkpoint_ns"],
                            "thread_id": "1",
                        },
                        "metadata": AnyDict(),
                        "recursion_limit": 25,
                        "tags": [],
                    },
                    "input": {
                        "messages": [
                            _AnyIdHumanMessage(content="what's the weather in sf")
                        ],
                        "route": "weather",
                    },
                    "finally_send": [
                        {
                            "topic": topics.executor,
                            "value": {
                                "config": {
                                    "callbacks": None,
                                    "configurable": {
                                        "__pregel_dedupe_tasks": True,
                                        "__pregel_ensure_latest": True,
                                        "__pregel_resuming": False,
                                        "checkpoint_id": history[0].config[
                                            "configurable"
                                        ]["checkpoint_id"],
                                        "checkpoint_ns": "",
                                        "thread_id": "1",
                                    },
                                    "metadata": AnyDict(),
                                    "recursion_limit": 25,
                                    "tags": [],
                                },
                                "finally_send": None,
                                "task": {
                                    "id": history[0].tasks[0].id,
                                    "path": list(history[0].tasks[0].path),
                                },
                            },
                        }
                    ],
                }
            ]
            # child graph messages, until interrupted
            + [
                {
                    "config": {
                        "callbacks": None,
                        "configurable": {
                            "__pregel_checkpointer": None,
                            "__pregel_delegate": False,
                            "__pregel_read": None,
                            "__pregel_send": None,
                            "__pregel_call": None,
                            "__pregel_ensure_latest": True,
                            "__pregel_store": None,
                            "__pregel_dedupe_tasks": True,
                            "__pregel_resuming": False,
                            "__pregel_previous": None,
                            "__pregel_task_id": history[0].tasks[0].id,
                            "__pregel_scratchpad": {
                                "subgraph_counter": None,
                                "call_counter": None,
                                "interrupt_counter": None,
                                "get_null_resume": None,
                                "resume": [],
                            },
                            "checkpoint_id": c.config["configurable"]["checkpoint_id"],
                            "checkpoint_map": {
                                "": history[0].config["configurable"]["checkpoint_id"]
                            },
                            "checkpoint_ns": history[0]
                            .tasks[0]
                            .state["configurable"]["checkpoint_ns"],
                            "thread_id": "1",
                        },
                        "metadata": AnyDict(),
                        "recursion_limit": 25,
                        "tags": [],
                    },
                    "input": None,
                    "finally_send": [
                        {
                            "topic": topics.executor,
                            "value": {
                                "config": {
                                    "callbacks": None,
                                    "configurable": {
                                        "__pregel_dedupe_tasks": True,
                                        "__pregel_ensure_latest": True,
                                        "__pregel_resuming": False,
                                        "checkpoint_id": history[0].config[
                                            "configurable"
                                        ]["checkpoint_id"],
                                        "checkpoint_ns": "",
                                        "thread_id": "1",
                                    },
                                    "metadata": AnyDict(),
                                    "recursion_limit": 25,
                                    "tags": [],
                                },
                                "finally_send": None,
                                "task": {
                                    "id": history[0].tasks[0].id,
                                    "path": list(history[0].tasks[0].path),
                                },
                            },
                        }
                    ],
                }
                for c in reversed(child_history[1:])  # the last one wasn't executed
                # orchestrator messages appear only after tasks for that checkpoint
                # finish executing, ie. after executor sends message to resume checkpoint
                for _ in c.tasks
            ]
        )
    )
    assert (
        exec_msgs
        == (
            # outer graph tasks
            [
                {
                    "config": {
                        "callbacks": None,
                        "configurable": {
                            "__pregel_ensure_latest": True,
                            "__pregel_dedupe_tasks": True,
                            "__pregel_resuming": False,
                            "checkpoint_id": c.config["configurable"]["checkpoint_id"],
                            "checkpoint_ns": "",
                            "thread_id": "1",
                        },
                        "metadata": AnyDict(),
                        "recursion_limit": 25,
                        "tags": [],
                    },
                    "task": {
                        "id": t.id,
                        "path": list(t.path),
                    },
                    "finally_send": None,
                }
                for c in reversed(history)
                for t in c.tasks
            ]
            # child graph tasks
            + [
                {
                    "config": {
                        "callbacks": None,
                        "configurable": {
                            "__pregel_checkpointer": None,
                            "__pregel_delegate": False,
                            "__pregel_read": None,
                            "__pregel_send": None,
                            "__pregel_call": None,
                            "__pregel_ensure_latest": True,
                            "__pregel_dedupe_tasks": True,
                            "__pregel_store": None,
                            "__pregel_resuming": False,
                            "__pregel_task_id": history[0].tasks[0].id,
                            "__pregel_previous": None,
                            "__pregel_scratchpad": {
                                "subgraph_counter": None,
                                "call_counter": None,
                                "interrupt_counter": None,
                                "get_null_resume": None,
                                "resume": [],
                            },
                            "checkpoint_id": c.config["configurable"]["checkpoint_id"],
                            "checkpoint_map": {
                                "": history[0].config["configurable"]["checkpoint_id"]
                            },
                            "checkpoint_ns": history[0]
                            .tasks[0]
                            .state["configurable"]["checkpoint_ns"],
                            "thread_id": "1",
                        },
                        "metadata": AnyDict(),
                        "recursion_limit": 25,
                        "tags": [],
                    },
                    "task": {
                        "id": t.id,
                        "path": list(t.path),
                    },
                    "finally_send": [
                        {
                            "topic": topics.executor,
                            "value": {
                                "config": {
                                    "callbacks": None,
                                    "configurable": {
                                        "__pregel_dedupe_tasks": True,
                                        "__pregel_ensure_latest": True,
                                        "__pregel_resuming": False,
                                        "checkpoint_id": history[0].config[
                                            "configurable"
                                        ]["checkpoint_id"],
                                        "checkpoint_ns": "",
                                        "thread_id": "1",
                                    },
                                    "metadata": AnyDict(),
                                    "recursion_limit": 25,
                                    "tags": [],
                                },
                                "finally_send": None,
                                "task": {
                                    "id": history[0].tasks[0].id,
                                    "path": list(history[0].tasks[0].path),
                                },
                            },
                        }
                    ],
                }
                for c in reversed(child_history[1:])  # the last one wasn't executed
                for t in c.tasks
            ]
        )
    )

    # resume the thread
    with DefaultProducer() as producer:
        producer.send(
            topics.orchestrator,
            value=serde.dumps(MessageToOrchestrator(input=None, config=config)),
        )
        producer.flush()

    orch_msgs, exec_msgs = drain_topics(topics, graph)

    # check final state
    state = graph.get_state(config)
    assert state.next == ()
    assert state.values == {
        "messages": [
            _AnyIdHumanMessage(content="what's the weather in sf"),
            _AnyIdAIMessage(content="I'ts sunny in San Francisco!"),
        ],
        "route": "weather",
    }

    # check outer history
    history = [c for c in graph.get_state_history(config)]
    assert len(history) == 4

    # check child history
    # accessing second to last checkpoint, since that's the one w/ subgraph task
    child_history = [c for c in graph.get_state_history(history[1].tasks[0].state)]
    assert len(child_history) == 4

    # check messages
    assert (
        orch_msgs
        == (
            # initial message to outer graph
            [MessageToOrchestrator(input=None, config=config)]
            # initial message to child graph
            + [
                {
                    "config": {
                        "callbacks": None,
                        "configurable": {
                            "__pregel_checkpointer": None,
                            "__pregel_delegate": False,
                            "__pregel_read": None,
                            "__pregel_send": None,
                            "__pregel_call": None,
                            "__pregel_ensure_latest": True,
                            "__pregel_dedupe_tasks": True,
                            "__pregel_store": None,
                            "__pregel_resuming": True,
                            "__pregel_previous": None,
                            "__pregel_task_id": history[1].tasks[0].id,
                            "__pregel_scratchpad": {
                                "subgraph_counter": None,
                                "call_counter": None,
                                "interrupt_counter": None,
                                "get_null_resume": None,
                                "resume": [],
                            },
                            "checkpoint_id": None,
                            "checkpoint_map": {
                                "": history[1].config["configurable"]["checkpoint_id"]
                            },
                            "checkpoint_ns": history[1]
                            .tasks[0]
                            .state["configurable"]["checkpoint_ns"],
                            "thread_id": "1",
                        },
                        "metadata": AnyDict(),
                        "recursion_limit": 25,
                        "tags": [],
                    },
                    "input": None,
                    "finally_send": [
                        {
                            "topic": topics.executor,
                            "value": {
                                "config": {
                                    "callbacks": None,
                                    "configurable": {
                                        "__pregel_dedupe_tasks": True,
                                        "__pregel_ensure_latest": True,
                                        "__pregel_resuming": True,
                                        "checkpoint_id": history[1].config[
                                            "configurable"
                                        ]["checkpoint_id"],
                                        "checkpoint_ns": "",
                                        "thread_id": "1",
                                    },
                                    "metadata": AnyDict(),
                                    "recursion_limit": 25,
                                    "tags": [],
                                },
                                "finally_send": None,
                                "task": {
                                    "id": history[1].tasks[0].id,
                                    "path": list(history[1].tasks[0].path),
                                },
                            },
                        }
                    ],
                }
            ]
            # child graph messages, from previous last checkpoint onwards
            + [
                {
                    "config": {
                        "callbacks": None,
                        "configurable": {
                            "__pregel_checkpointer": None,
                            "__pregel_delegate": False,
                            "__pregel_read": None,
                            "__pregel_send": None,
                            "__pregel_call": None,
                            "__pregel_ensure_latest": True,
                            "__pregel_dedupe_tasks": True,
                            "__pregel_store": None,
                            "__pregel_resuming": True,
                            "__pregel_previous": None,
                            "__pregel_task_id": history[1].tasks[0].id,
                            "__pregel_scratchpad": {
                                "subgraph_counter": None,
                                "call_counter": None,
                                "interrupt_counter": None,
                                "get_null_resume": None,
                                "resume": [],
                            },
                            "checkpoint_id": c.config["configurable"]["checkpoint_id"],
                            "checkpoint_map": {
                                "": history[1].config["configurable"]["checkpoint_id"]
                            },
                            "checkpoint_ns": history[1]
                            .tasks[0]
                            .state["configurable"]["checkpoint_ns"],
                            "thread_id": "1",
                        },
                        "metadata": AnyDict(),
                        "recursion_limit": 25,
                        "tags": [],
                    },
                    "input": None,
                    "finally_send": [
                        {
                            "topic": topics.executor,
                            "value": {
                                "config": {
                                    "callbacks": None,
                                    "configurable": {
                                        "__pregel_dedupe_tasks": True,
                                        "__pregel_ensure_latest": True,
                                        "__pregel_resuming": True,
                                        "checkpoint_id": history[1].config[
                                            "configurable"
                                        ]["checkpoint_id"],
                                        "checkpoint_ns": "",
                                        "thread_id": "1",
                                    },
                                    "metadata": AnyDict(),
                                    "recursion_limit": 25,
                                    "tags": [],
                                },
                                "finally_send": None,
                                "task": {
                                    "id": history[1].tasks[0].id,
                                    "path": list(history[1].tasks[0].path),
                                },
                            },
                        }
                    ],
                }
                for c in reversed(child_history[:2])
                for _ in c.tasks
            ]
            # outer graph messages, from previous last checkpoint onwards
            + [
                {
                    "config": {
                        "callbacks": None,
                        "configurable": {
                            "__pregel_ensure_latest": True,
                            "__pregel_dedupe_tasks": True,
                            "__pregel_resuming": True,
                            "checkpoint_id": c.config["configurable"]["checkpoint_id"],
                            "checkpoint_ns": "",
                            "thread_id": "1",
                        },
                        "metadata": AnyDict(),
                        "recursion_limit": 25,
                        "tags": [],
                    },
                    "input": None,
                    "finally_send": None,
                }
                for c in reversed(history[:2])
                for _ in c.tasks
            ]
        )
    )
    assert (
        exec_msgs
        == (
            # outer graph tasks
            [
                {
                    "config": {
                        "callbacks": None,
                        "configurable": {
                            "__pregel_ensure_latest": True,
                            "__pregel_dedupe_tasks": True,
                            "__pregel_resuming": True,
                            "checkpoint_id": c.config["configurable"]["checkpoint_id"],
                            "checkpoint_ns": "",
                            "thread_id": "1",
                        },
                        "metadata": AnyDict(),
                        "recursion_limit": 25,
                        "tags": [],
                    },
                    "task": {
                        "id": t.id,
                        "path": list(t.path),
                    },
                    "finally_send": None,
                }
                for c in reversed(history[:2])
                for t in c.tasks
            ]
            # child graph tasks
            + [
                {
                    "config": {
                        "callbacks": None,
                        "configurable": {
                            "__pregel_checkpointer": None,
                            "__pregel_delegate": False,
                            "__pregel_read": None,
                            "__pregel_send": None,
                            "__pregel_call": None,
                            "__pregel_ensure_latest": True,
                            "__pregel_dedupe_tasks": True,
                            "__pregel_resuming": True,
                            "__pregel_previous": None,
                            "__pregel_store": None,
                            "__pregel_task_id": history[1].tasks[0].id,
                            "__pregel_scratchpad": {
                                "subgraph_counter": None,
                                "call_counter": None,
                                "interrupt_counter": None,
                                "get_null_resume": None,
                                "resume": [],
                            },
                            "checkpoint_id": c.config["configurable"]["checkpoint_id"],
                            "checkpoint_map": {
                                "": history[1].config["configurable"]["checkpoint_id"]
                            },
                            "checkpoint_ns": history[1]
                            .tasks[0]
                            .state["configurable"]["checkpoint_ns"],
                            "thread_id": "1",
                        },
                        "metadata": AnyDict(),
                        "recursion_limit": 25,
                        "tags": [],
                    },
                    "task": {
                        "id": t.id,
                        "path": list(t.path),
                    },
                    "finally_send": [
                        {
                            "topic": topics.executor,
                            "value": {
                                "config": {
                                    "callbacks": None,
                                    "configurable": {
                                        "__pregel_dedupe_tasks": True,
                                        "__pregel_ensure_latest": True,
                                        "__pregel_resuming": True,
                                        "checkpoint_id": history[1].config[
                                            "configurable"
                                        ]["checkpoint_id"],
                                        "checkpoint_ns": "",
                                        "thread_id": "1",
                                    },
                                    "metadata": AnyDict(),
                                    "recursion_limit": 25,
                                    "tags": [],
                                },
                                "finally_send": None,
                                "task": {
                                    "id": history[1].tasks[0].id,
                                    "path": list(history[1].tasks[0].path),
                                },
                            },
                        }
                    ],
                }
                for c in reversed(child_history[:2])
                for t in c.tasks
            ]
            # "finally" tasks
            + [
                {
                    "config": {
                        "callbacks": None,
                        "configurable": {
                            "__pregel_dedupe_tasks": True,
                            "__pregel_ensure_latest": True,
                            "__pregel_resuming": True,
                            "checkpoint_id": history[1].config["configurable"][
                                "checkpoint_id"
                            ],
                            "checkpoint_ns": "",
                            "thread_id": "1",
                        },
                        "metadata": AnyDict(),
                        "recursion_limit": 25,
                        "tags": [],
                    },
                    "finally_send": None,
                    "task": {
                        "id": history[1].tasks[0].id,
                        "path": list(history[1].tasks[0].path),
                    },
                }
            ]
        )
    )