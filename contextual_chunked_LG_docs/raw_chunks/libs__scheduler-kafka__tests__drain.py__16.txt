def drain_topics(
    topics: Topics, graph: Pregel, *, debug: bool = False
) -> tuple[list[MessageToOrchestrator], list[MessageToOrchestrator]]:
    orch_msgs = []
    exec_msgs = []
    errors = []
    event = threading.Event()

    def done() -> bool:
        return (
            len(orch_msgs) > 0
            and any(orch_msgs)
            and len(exec_msgs) > 0
            and any(exec_msgs)
            and not orch_msgs[-1]
            and not exec_msgs[-1]
        )

    def orchestrator() -> None:
        try:
            with KafkaOrchestrator(graph, topics) as orch:
                for msgs in orch:
                    orch_msgs.append(msgs)
                    if debug:
                        print("\n---\norch", len(msgs), msgs)
                    if done():
                        event.set()
                    if event.is_set():
                        break
        except Exception as e:
            errors.append(e)
            event.set()

    def executor() -> None:
        try:
            with KafkaExecutor(graph, topics) as exec:
                for msgs in exec:
                    exec_msgs.append(msgs)
                    if debug:
                        print("\n---\nexec", len(msgs), msgs)
                    if done():
                        event.set()
                    if event.is_set():
                        break
        except Exception as e:
            errors.append(e)
            event.set()

    def error_consumer() -> None:
        try:
            with DefaultConsumer(topics.error) as consumer:
                while not event.is_set():
                    if msg := consumer.poll(timeout_ms=100):
                        errors.append(msg)
                        event.set()
        except Exception as e:
            errors.append(e)
            event.set()

    with ThreadPoolExecutor() as pool:
        # start error consumer
        pool.submit(error_consumer)

        # run the orchestrator and executor until break_when
        pool.submit(orchestrator)
        pool.submit(executor)

        # timeout
        start = time.time()
        while not event.is_set():
            time.sleep(0.1)
            if time.time() - start > 20:
                event.set()

    # check no errors
    assert not errors, errors

    return [m for mm in orch_msgs for m in mm], [m for mm in exec_msgs for m in mm]